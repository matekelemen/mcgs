<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MCGS: mcgs Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MCGS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacemcgs.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mcgs Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmcgs_1_1CSRAdaptor.html">CSRAdaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor for matrices stored in the compressed sparse row format.  <a href="structmcgs_1_1CSRAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmcgs_1_1ColorSettings.html">ColorSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Settings for the coloring algorithm.  <a href="structmcgs_1_1ColorSettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmcgs_1_1Partition.html">Partition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmcgs_1_1Partition.html" title="Partition of a graph with respect to a coloring.">Partition</a> of a graph with respect to a coloring.  <a href="classmcgs_1_1Partition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmcgs_1_1SolveSettings.html">SolveSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Settings for Gauss-Seidel relaxation.  <a href="structmcgs_1_1SolveSettings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a06ea4c8469385d263f5414c804d23e86"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemcgs.html#a06ea4c8469385d263f5414c804d23e86">Parallelization</a> { <a class="el" href="namespacemcgs.html#a06ea4c8469385d263f5414c804d23e86a6adf97f83acf6453d4a6a4b1070f3754">None</a> = 1
, <a class="el" href="namespacemcgs.html#a06ea4c8469385d263f5414c804d23e86ae7968e8fd57987542f4a09aafaf672c7">RowWise</a> = 2
, <a class="el" href="namespacemcgs.html#a06ea4c8469385d263f5414c804d23e86a0e367d90e7da76172482c7563990a87b">EntryWise</a> = 4
 }</td></tr>
<tr class="memdesc:a06ea4c8469385d263f5414c804d23e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum for all supported Gauss-Seidel parallelization strategies.  <a href="namespacemcgs.html#a06ea4c8469385d263f5414c804d23e86">More...</a><br /></td></tr>
<tr class="separator:a06ea4c8469385d263f5414c804d23e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad660f970843b8c8edea18c6e9291f6e5"><td class="memTemplParams" colspan="2">template&lt;class TIndex , class TValue , class TColor &gt; </td></tr>
<tr class="memitem:ad660f970843b8c8edea18c6e9291f6e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="mcgs_8hpp.html#aab5410ee7a713fbb951076236bc95b47">MCGS_EXPORT_SYMBOL</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemcgs.html#ad660f970843b8c8edea18c6e9291f6e5">color</a> (TColor *pColors, const <a class="el" href="structmcgs_1_1CSRAdaptor.html">CSRAdaptor</a>&lt; TIndex, TValue &gt; &amp;rMatrix, const <a class="el" href="structmcgs_1_1ColorSettings.html">ColorSettings</a>&lt; TValue &gt; settings)</td></tr>
<tr class="memdesc:ad660f970843b8c8edea18c6e9291f6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an approximate coloring of a graph.  <a href="namespacemcgs.html#ad660f970843b8c8edea18c6e9291f6e5">More...</a><br /></td></tr>
<tr class="separator:ad660f970843b8c8edea18c6e9291f6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1b31c2c7598785869990911fc47d26"><td class="memTemplParams" colspan="2">template&lt;class TIndex , class TColor &gt; </td></tr>
<tr class="memitem:a1f1b31c2c7598785869990911fc47d26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="mcgs_8hpp.html#aab5410ee7a713fbb951076236bc95b47">MCGS_EXPORT_SYMBOL</a> <a class="el" href="classmcgs_1_1Partition.html">Partition</a>&lt; TIndex &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemcgs.html#a1f1b31c2c7598785869990911fc47d26">makePartition</a> (const TColor *pColors, const TIndex rowCount)</td></tr>
<tr class="memdesc:a1f1b31c2c7598785869990911fc47d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the <a class="el" href="classmcgs_1_1Partition.html">Partition</a> of a graph with respect to a coloring.  <a href="namespacemcgs.html#a1f1b31c2c7598785869990911fc47d26">More...</a><br /></td></tr>
<tr class="separator:a1f1b31c2c7598785869990911fc47d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad619ded9f67d8a9f379ad7e4b759d854"><td class="memTemplParams" colspan="2">template&lt;class TIndex &gt; </td></tr>
<tr class="memitem:ad619ded9f67d8a9f379ad7e4b759d854"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="mcgs_8hpp.html#aab5410ee7a713fbb951076236bc95b47">MCGS_EXPORT_SYMBOL</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemcgs.html#ad619ded9f67d8a9f379ad7e4b759d854">destroyPartition</a> (<a class="el" href="classmcgs_1_1Partition.html">Partition</a>&lt; TIndex &gt; *pPartition)</td></tr>
<tr class="memdesc:ad619ded9f67d8a9f379ad7e4b759d854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a partition that was successfully constructed by <a class="el" href="namespacemcgs.html#a1f1b31c2c7598785869990911fc47d26">makePartition</a>.  <a href="namespacemcgs.html#ad619ded9f67d8a9f379ad7e4b759d854">More...</a><br /></td></tr>
<tr class="separator:ad619ded9f67d8a9f379ad7e4b759d854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17236ad40bf333770b858d20b1e860fb"><td class="memTemplParams" colspan="2">template&lt;class TIndex , class TValue &gt; </td></tr>
<tr class="memitem:a17236ad40bf333770b858d20b1e860fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="mcgs_8hpp.html#aab5410ee7a713fbb951076236bc95b47">MCGS_EXPORT_SYMBOL</a> <a class="el" href="classmcgs_1_1Partition.html">Partition</a>&lt; TIndex &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemcgs.html#a17236ad40bf333770b858d20b1e860fb">reorder</a> (const unsigned long rowCount, const unsigned long columnCount, const unsigned long entryCount, TIndex *pRowExtents, TIndex *pColumnIndices, TValue *pEntries, TValue *pSolution, TValue *pRHS, const <a class="el" href="classmcgs_1_1Partition.html">Partition</a>&lt; TIndex &gt; *pPartition)</td></tr>
<tr class="memdesc:a17236ad40bf333770b858d20b1e860fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder rows and columns of a CSR matrix as well as a matching dense vector, with respect to a coloring.  <a href="namespacemcgs.html#a17236ad40bf333770b858d20b1e860fb">More...</a><br /></td></tr>
<tr class="separator:a17236ad40bf333770b858d20b1e860fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac684ffc12d9d07249de79137ebfa4ad0"><td class="memTemplParams" colspan="2">template&lt;class TIndex , class TValue &gt; </td></tr>
<tr class="memitem:ac684ffc12d9d07249de79137ebfa4ad0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="mcgs_8hpp.html#aab5410ee7a713fbb951076236bc95b47">MCGS_EXPORT_SYMBOL</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemcgs.html#ac684ffc12d9d07249de79137ebfa4ad0">revertReorder</a> (TValue *pRHS, const unsigned long rowCount, const <a class="el" href="classmcgs_1_1Partition.html">Partition</a>&lt; TIndex &gt; *pPartition)</td></tr>
<tr class="memdesc:ac684ffc12d9d07249de79137ebfa4ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the original order of a <a class="el" href="namespacemcgs.html#a17236ad40bf333770b858d20b1e860fb">reordered</a> vector.  <a href="namespacemcgs.html#ac684ffc12d9d07249de79137ebfa4ad0">More...</a><br /></td></tr>
<tr class="separator:ac684ffc12d9d07249de79137ebfa4ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379ac2b643fb29026da916d73273d92f"><td class="memTemplParams" colspan="2">template&lt;class TIndex , class TValue &gt; </td></tr>
<tr class="memitem:a379ac2b643fb29026da916d73273d92f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="mcgs_8hpp.html#aab5410ee7a713fbb951076236bc95b47">MCGS_EXPORT_SYMBOL</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemcgs.html#a379ac2b643fb29026da916d73273d92f">revertReorder</a> (const unsigned long rowCount, const unsigned long columnCount, const unsigned long entryCount, TIndex *pRowExtents, TIndex *pColumnIndices, TValue *pEntries, TValue *pSolution, TValue *pRHS, const <a class="el" href="classmcgs_1_1Partition.html">Partition</a>&lt; TIndex &gt; *pPartition)</td></tr>
<tr class="memdesc:a379ac2b643fb29026da916d73273d92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore the original order of a <a class="el" href="namespacemcgs.html#a17236ad40bf333770b858d20b1e860fb">reordered</a> CSR matrix and associated right hand side vector.  <a href="namespacemcgs.html#a379ac2b643fb29026da916d73273d92f">More...</a><br /></td></tr>
<tr class="separator:a379ac2b643fb29026da916d73273d92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9a66158dc4ae9f2191bef17c6160cf"><td class="memTemplParams" colspan="2">template&lt;class TIndex , class TValue &gt; </td></tr>
<tr class="memitem:aba9a66158dc4ae9f2191bef17c6160cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="mcgs_8hpp.html#aab5410ee7a713fbb951076236bc95b47">MCGS_EXPORT_SYMBOL</a> TValue&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemcgs.html#aba9a66158dc4ae9f2191bef17c6160cf">residual</a> (const <a class="el" href="structmcgs_1_1CSRAdaptor.html">CSRAdaptor</a>&lt; TIndex, TValue &gt; &amp;rMatrix, const TValue *pSolution, const TValue *pRHS) noexcept</td></tr>
<tr class="memdesc:aba9a66158dc4ae9f2191bef17c6160cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 2-norm of the residual of a linear system's approximate solution.  <a href="namespacemcgs.html#aba9a66158dc4ae9f2191bef17c6160cf">More...</a><br /></td></tr>
<tr class="separator:aba9a66158dc4ae9f2191bef17c6160cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a15788e753a30cc3f8f621ba2a48fb"><td class="memTemplParams" colspan="2">template&lt;class TIndex , class TValue &gt; </td></tr>
<tr class="memitem:a87a15788e753a30cc3f8f621ba2a48fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="mcgs_8hpp.html#aab5410ee7a713fbb951076236bc95b47">MCGS_EXPORT_SYMBOL</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemcgs.html#a87a15788e753a30cc3f8f621ba2a48fb">solve</a> (TValue *pSolution, const <a class="el" href="structmcgs_1_1CSRAdaptor.html">CSRAdaptor</a>&lt; TIndex, TValue &gt; &amp;rMatrix, const TValue *pRHS, const <a class="el" href="structmcgs_1_1SolveSettings.html">SolveSettings</a>&lt; TIndex, TValue &gt; settings)</td></tr>
<tr class="memdesc:a87a15788e753a30cc3f8f621ba2a48fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform Gauss-Seidel relaxation in serial.  <a href="namespacemcgs.html#a87a15788e753a30cc3f8f621ba2a48fb">More...</a><br /></td></tr>
<tr class="separator:a87a15788e753a30cc3f8f621ba2a48fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4022f391e69fa07ab52486195906764"><td class="memTemplParams" colspan="2">template&lt;class TIndex , class TValue &gt; </td></tr>
<tr class="memitem:ae4022f391e69fa07ab52486195906764"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="mcgs_8hpp.html#aab5410ee7a713fbb951076236bc95b47">MCGS_EXPORT_SYMBOL</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemcgs.html#ae4022f391e69fa07ab52486195906764">solve</a> (TValue *pSolution, const <a class="el" href="structmcgs_1_1CSRAdaptor.html">CSRAdaptor</a>&lt; TIndex, TValue &gt; &amp;rMatrix, const TValue *pRHS, const <a class="el" href="classmcgs_1_1Partition.html">Partition</a>&lt; TIndex &gt; *pPartition, const <a class="el" href="structmcgs_1_1SolveSettings.html">SolveSettings</a>&lt; TIndex, TValue &gt; settings)</td></tr>
<tr class="memdesc:ae4022f391e69fa07ab52486195906764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform Gauss-Seidel relaxation on a reordered system in parallel.  <a href="namespacemcgs.html#ae4022f391e69fa07ab52486195906764">More...</a><br /></td></tr>
<tr class="separator:ae4022f391e69fa07ab52486195906764"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a06ea4c8469385d263f5414c804d23e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ea4c8469385d263f5414c804d23e86">&#9670;&nbsp;</a></span>Parallelization</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemcgs.html#a06ea4c8469385d263f5414c804d23e86">mcgs::Parallelization</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enum for all supported Gauss-Seidel parallelization strategies. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a06ea4c8469385d263f5414c804d23e86a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>Perform Gauss-Seidel iterations in serial. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06ea4c8469385d263f5414c804d23e86ae7968e8fd57987542f4a09aafaf672c7"></a>RowWise&#160;</td><td class="fielddoc"><p>Distribute work assuming each row has the same number of entries. </p>
</td></tr>
<tr><td class="fieldname"><a id="a06ea4c8469385d263f5414c804d23e86a0e367d90e7da76172482c7563990a87b"></a>EntryWise&#160;</td><td class="fielddoc"><p>Distribute work along equal chunks of entries. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad660f970843b8c8edea18c6e9291f6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad660f970843b8c8edea18c6e9291f6e5">&#9670;&nbsp;</a></span>color()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIndex , class TValue , class TColor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mcgs_8hpp.html#aab5410ee7a713fbb951076236bc95b47">MCGS_EXPORT_SYMBOL</a> int mcgs::color </td>
          <td>(</td>
          <td class="paramtype">TColor *&#160;</td>
          <td class="paramname"><em>pColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmcgs_1_1CSRAdaptor.html">CSRAdaptor</a>&lt; TIndex, TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>rMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmcgs_1_1ColorSettings.html">ColorSettings</a>&lt; TValue &gt;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute an approximate coloring of a graph. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIndex</td><td>Integer type of stored indices in the matrix (<code>int</code>, <code>long</code>, <code>unsigned</code> or <code>unsigned long</code>). </td></tr>
    <tr><td class="paramname">TValue</td><td>Number type of stored entries in the matrix (for now, only <code>double</code> is supported). </td></tr>
    <tr><td class="paramname">TColor</td><td>Integer type of vertex colors (<code>unsigned</code> or <code>unsigned long</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Output</dt><dd>The output is written to <code>pColors</code>, which stores the color of each row at the matching index.</dd></dl>
<dl class="section user"><dt>Algorithm</dt><dd>The algorithm randomly assigns colors to each uncolored vertex from their palette of remaining colors. After each round of assignment, vertices with valid colors are frozen and a basic conflict resolution step is carried out. The color of newly frozen vertices is removed from their neighbors' palettes.</dd></dl>
<p>The quality of the resulting coloring, as well as the number of iterations to find it strongly depend on the size of the initial palettes. This can be adjusted via the <a class="el" href="structmcgs_1_1ColorSettings.html#aaa5eb5eb3aec267fb8523a7670b2480b">shrinking factor</a>, which is the only algorithmic parameter.</p>
<dl class="section user"><dt>Parallelism</dt><dd>Coloring is performed in parallel on the CPU in a shared memory model using <em>OpenMP</em>, if <em>MCGS</em> was compiled with <em>OpenMP</em> support. The maximum number of used threads is controlled by <em>OpenMP</em>.</dd></dl>
<dl class="section user"><dt>Stalling</dt><dd>Due to the random nature of assignments, iterations that fail to freeze the color of any remaining vertex can occur. Such an iteration is labelled a stalled iteration, and the function is set to fail after a given number of consequent stalls. The length of tolerated consequent stalls is controlled by <a class="el" href="structmcgs_1_1ColorSettings.html#a5e6b9d55d5f1e33e18ad93f4a36a0b21">ColorSettings::maxStallCount</a>.</dd></dl>
<dl class="section user"><dt>Errors</dt><dd>The algorithm can fail if<ul>
<li>the number of consequent stalls reaches <a class="el" href="structmcgs_1_1ColorSettings.html#a5e6b9d55d5f1e33e18ad93f4a36a0b21">ColorSettings::maxStallCount</a></li>
<li>the number of rows, columns, or nonzeros in the input matrix is negative</li>
<li>the input matrix is not square</li>
<li><a class="el" href="structmcgs_1_1CSRAdaptor.html#a6104cdda3c9e66643478307b8f0f3dd2">CSRAdaptor::pRowExtents</a>, <a class="el" href="structmcgs_1_1CSRAdaptor.html#aa70eacd66e3f78e776dd5011a3b92744">CSRAdaptor::pColumnIndices</a>, or <a class="el" href="structmcgs_1_1CSRAdaptor.html#a2869534a5ed297aedd8df5f81f0cf294">CSRAdaptor::pEntries</a> is <code>nullptr</code>.</li>
<li><code>pColors</code> is <code>nullptr</code> If any of the above is detected, the function returns <a class="el" href="mcgs_8hpp.html#a212b21098b92f9d4db5bb30a9382e30d">MCGS_FAILURE</a>.</li>
</ul>
</dd></dl>
<p>No exceptions are thrown by the function directly, but exceptions from the C++ standard library can propagate to the user (provided that exceptions are enabled by the compiler).</p>
<p>Segmentation faults can occur if the user manages the memory of the input matrix or output colors incorrectly. Requirements on matrix storage are specified by <a class="el" href="structmcgs_1_1CSRAdaptor.html">CSRAdaptor</a>. <code>pColors</code> must be at least of length <a class="el" href="structmcgs_1_1CSRAdaptor.html#ae2dd01c5485f57bacc1328afa1b9d5c6">CSRAdaptor::rowCount</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pColors</td><td>output array of vertex colors. The memory must be managed by the user, and the array must have a length at least as the number of columns in the input matrix <code>rMatrix</code>. </td></tr>
    <tr><td class="paramname">rMatrix</td><td><a class="el" href="structmcgs_1_1CSRAdaptor.html">CSR matrix adaptor</a> representing the graph to be colored. </td></tr>
    <tr><td class="paramname">settings</td><td><a class="el" href="structmcgs_1_1ColorSettings.html">algorithmic parameters and other settings</a> to apply during coloring.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="mcgs_8hpp.html#a46be1634119b41c983ab52281fc0aca2">MCGS_SUCCESS</a> if successful, otherwise <a class="el" href="mcgs_8hpp.html#a212b21098b92f9d4db5bb30a9382e30d">MCGS_FAILURE</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is a loose implementation of the algorithm described in <em>Fast Distributed Algorithms for Brooks-Vizing Colorings</em>, doi:<code>10.1006/jagm.2000.1097</code>. </dd></dl>

</div>
</div>
<a id="ad619ded9f67d8a9f379ad7e4b759d854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad619ded9f67d8a9f379ad7e4b759d854">&#9670;&nbsp;</a></span>destroyPartition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mcgs_8hpp.html#aab5410ee7a713fbb951076236bc95b47">MCGS_EXPORT_SYMBOL</a> void mcgs::destroyPartition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmcgs_1_1Partition.html">Partition</a>&lt; TIndex &gt; *&#160;</td>
          <td class="paramname"><em>pPartition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a partition that was successfully constructed by <a class="el" href="namespacemcgs.html#a1f1b31c2c7598785869990911fc47d26">makePartition</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIndex</td><td>Integer type of stored indices in the matrix (<code>int</code>, <code>long</code>, <code>unsigned</code> or <code>unsigned long</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPartition</td><td>Pointer to the <a class="el" href="classmcgs_1_1Partition.html">Partition</a> to destroy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>successful calls to <a class="el" href="namespacemcgs.html#a1f1b31c2c7598785869990911fc47d26">makePartition</a> must be followed by a matching call to <code>destroyPartition</code>, once the constructed <a class="el" href="classmcgs_1_1Partition.html">Partition</a> is no longer used. Memory allocated by the partition will otherwise not be released.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemcgs.html#a1f1b31c2c7598785869990911fc47d26" title="Construct the Partition of a graph with respect to a coloring.">makePartition</a> </dd></dl>

</div>
</div>
<a id="a1f1b31c2c7598785869990911fc47d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1b31c2c7598785869990911fc47d26">&#9670;&nbsp;</a></span>makePartition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIndex , class TColor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mcgs_8hpp.html#aab5410ee7a713fbb951076236bc95b47">MCGS_EXPORT_SYMBOL</a> <a class="el" href="classmcgs_1_1Partition.html">Partition</a>&lt;TIndex&gt;* mcgs::makePartition </td>
          <td>(</td>
          <td class="paramtype">const TColor *&#160;</td>
          <td class="paramname"><em>pColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex&#160;</td>
          <td class="paramname"><em>rowCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the <a class="el" href="classmcgs_1_1Partition.html">Partition</a> of a graph with respect to a coloring. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIndex</td><td>Integer type of stored indices in the matrix (<code>int</code>, <code>long</code>, <code>unsigned</code> or <code>unsigned long</code>). </td></tr>
    <tr><td class="paramname">TColor</td><td>Integer type of vertex colors (<code>unsigned</code> or <code>unsigned long</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pColors</td><td>Array of vertex colors. </td></tr>
    <tr><td class="paramname">rowCount</td><td>Number of vertices (must match the number of rows of the matrix representation of the graph).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a valid pointer to a partition if successful, otherwise <code>nullptr</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>successful partitionings <b>must</b> be destroyed explicitly by the user with <a class="el" href="namespacemcgs.html#ad619ded9f67d8a9f379ad7e4b759d854">destroyPartition</a>.</li>
<li>if partitioning fails, a <code>nullptr</code> is returned. In such cases, the user must not invoke <a class="el" href="namespacemcgs.html#ad619ded9f67d8a9f379ad7e4b759d854">destroyPartition</a> with the returned pointer.</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemcgs.html#ad619ded9f67d8a9f379ad7e4b759d854" title="Destroy a partition that was successfully constructed by makePartition.">destroyPartition</a> </dd></dl>

</div>
</div>
<a id="a17236ad40bf333770b858d20b1e860fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17236ad40bf333770b858d20b1e860fb">&#9670;&nbsp;</a></span>reorder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIndex , class TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mcgs_8hpp.html#aab5410ee7a713fbb951076236bc95b47">MCGS_EXPORT_SYMBOL</a> <a class="el" href="classmcgs_1_1Partition.html">Partition</a>&lt;TIndex&gt;* mcgs::reorder </td>
          <td>(</td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>rowCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>columnCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>entryCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex *&#160;</td>
          <td class="paramname"><em>pRowExtents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex *&#160;</td>
          <td class="paramname"><em>pColumnIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TValue *&#160;</td>
          <td class="paramname"><em>pEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TValue *&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TValue *&#160;</td>
          <td class="paramname"><em>pRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcgs_1_1Partition.html">Partition</a>&lt; TIndex &gt; *&#160;</td>
          <td class="paramname"><em>pPartition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder rows and columns of a CSR matrix as well as a matching dense vector, with respect to a coloring. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIndex</td><td>Integer type of stored indices in the matrix (<code>int</code>, <code>long</code>, <code>unsigned</code> or <code>unsigned long</code>). </td></tr>
    <tr><td class="paramname">TValue</td><td>Number type of stored entries in the matrix (for now, only <code>double</code> is supported).</td></tr>
  </table>
  </dd>
</dl>
<p>This function reorders the rows of a matrix stored in the compressed sparse row format such that rows with identical colors become contiguous. Columns of the matrix, as well as the associated right hand side vector <code>pRHS</code> are reordered accordingly.</p>
<p>A new partition is returned in which rows of the same color are contiguous. Such a partition is a prerequisite for running <a class="el" href="namespacemcgs.html#ae4022f391e69fa07ab52486195906764">parallel versions of Gauss-Seidel smoothing</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowCount</td><td>Number of rows in the matrix. </td></tr>
    <tr><td class="paramname">columnCount</td><td>Number of columns in the matrix. </td></tr>
    <tr><td class="paramname">entryCount</td><td>Number of entries stored in the compressed matrix. </td></tr>
    <tr><td class="paramname">pRowExtents</td><td>Index array defining entries in the matrix related to each row in <code>pEntries</code>. Size must be at least <code>rowCount + 1</code>. </td></tr>
    <tr><td class="paramname">pColumnIndices</td><td>Index array assigning column indices to each entry in <code>pEntries</code>. Size must be at least <code>entryCount</code>. </td></tr>
    <tr><td class="paramname">pEntries</td><td>Array of stored entries in the matrix. Size must be at least <code>entryCount</code>. </td></tr>
    <tr><td class="paramname">pSolution</td><td>Initial solution vector stored in a dense contiguous array. Size must be at least <code>columnCount</code>. Pass <code>nullptr</code> if you don't want to reorder the initial solution vector. </td></tr>
    <tr><td class="paramname">pRHS</td><td>Right hand side vector stored in a dense contiguous array. Size must be at least <code>rowCount</code>. Pass <code>nullptr</code> if you don't want to reorder the right hand side vector. </td></tr>
    <tr><td class="paramname">pPartition</td><td>Pointer to the partition that encodes the coloring of the input matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a contiguous partition of the reordered system if the reordering is successful, otherwise <code>nullptr</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The function allocates a duplicate of the input matrix, vector and partition during execution.</li>
<li>The returned partition must be destroyed explicitly by the user with <a class="el" href="namespacemcgs.html#ad619ded9f67d8a9f379ad7e4b759d854">destroyPartition</a> (provided the reordering was successful).</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd>revertReorder(TValue*,const TIndex,const Partition*) </dd>
<dd>
revertReorder(const TIndex,const TIndex,const TIndex,TIndex*,TIndex*,TValue*,TValue*,TValue*,const Partition*) </dd></dl>

</div>
</div>
<a id="aba9a66158dc4ae9f2191bef17c6160cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9a66158dc4ae9f2191bef17c6160cf">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIndex , class TValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mcgs_8hpp.html#aab5410ee7a713fbb951076236bc95b47">MCGS_EXPORT_SYMBOL</a> TValue mcgs::residual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmcgs_1_1CSRAdaptor.html">CSRAdaptor</a>&lt; TIndex, TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>rMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TValue *&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TValue *&#160;</td>
          <td class="paramname"><em>pRHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the 2-norm of the residual of a linear system's approximate solution. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIndex</td><td>Integer type of stored indices in the matrix (<code>int</code>, <code>long</code>, <code>unsigned</code> or <code>unsigned long</code>). </td></tr>
    <tr><td class="paramname">TValue</td><td>Number type of stored entries in the matrix (for now, only <code>double</code> is supported).</td></tr>
  </table>
  </dd>
</dl>
<p class="formulaDsp">
\[ r = \sqrt{\sum_i{(b_i - a_{ij}x_j)^2}} \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rMatrix</td><td>Left hand side square matrix in compressed sparse row format ( \(a_{ij}\)). </td></tr>
    <tr><td class="paramname">pSolution</td><td>Approximate solution vector ( \(x_j\)). Size must be at least equal to the number of <a class="el" href="structmcgs_1_1CSRAdaptor.html#ae3747b5a9e79c0537a4b3da9469b9949">columns</a> in the matrix. </td></tr>
    <tr><td class="paramname">pRHS</td><td>Right hand side vector ( \(b_i\)). Size must be at least equal to the number of <a class="el" href="structmcgs_1_1CSRAdaptor.html#ae2dd01c5485f57bacc1328afa1b9d5c6">rows</a> in the matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The residual's 2-norm. </dd></dl>

</div>
</div>
<a id="a379ac2b643fb29026da916d73273d92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379ac2b643fb29026da916d73273d92f">&#9670;&nbsp;</a></span>revertReorder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIndex , class TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mcgs::revertReorder </td>
          <td>(</td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>rowCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>columnCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>entryCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex *&#160;</td>
          <td class="paramname"><em>pRowExtents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TIndex *&#160;</td>
          <td class="paramname"><em>pColumnIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TValue *&#160;</td>
          <td class="paramname"><em>pEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TValue *&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TValue *&#160;</td>
          <td class="paramname"><em>pRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcgs_1_1Partition.html">Partition</a>&lt; TIndex &gt; *&#160;</td>
          <td class="paramname"><em>pPartition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore the original order of a <a class="el" href="namespacemcgs.html#a17236ad40bf333770b858d20b1e860fb">reordered</a> CSR matrix and associated right hand side vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIndex</td><td>Integer type of stored indices in the matrix (<code>int</code>, <code>long</code>, <code>unsigned</code> or <code>unsigned long</code>). </td></tr>
    <tr><td class="paramname">TValue</td><td>Number type of stored entries in the matrix (for now, only <code>double</code> is supported).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowCount</td><td>Number of rows in the matrix. </td></tr>
    <tr><td class="paramname">columnCount</td><td>Number of columns in the matrix. </td></tr>
    <tr><td class="paramname">entryCount</td><td>Number of entries stored in the compressed matrix. </td></tr>
    <tr><td class="paramname">pRowExtents</td><td>Index array defining entries in the matrix related to each row in <code>pEntries</code>. Size must be at least <code>rowCount + 1</code>. </td></tr>
    <tr><td class="paramname">pColumnIndices</td><td>Index array assigning column indices to each entry in <code>pEntries</code>. Size must be at least <code>entryCount</code>. </td></tr>
    <tr><td class="paramname">pEntries</td><td>Array of stored entries in the matrix. Size must be at least <code>entryCount</code>. </td></tr>
    <tr><td class="paramname">pSolution</td><td>Initial solution vector stored in a dense contiguous array. Size must be at least <code>columnCount</code>. Pass <code>nullptr</code> if you don't want to reorder the initial solution vector. </td></tr>
    <tr><td class="paramname">pRHS</td><td>Right hand side vector stored in a dense contiguous array. Size must be at least <code>rowCount</code>. Pass <code>nullptr</code> if you don't want to reorder the right hand side vector. </td></tr>
    <tr><td class="paramname">pPartition</td><td>Pointer to the original <a class="el" href="classmcgs_1_1Partition.html">Partition</a> the matrix and vector were reordered by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="mcgs_8hpp.html#a46be1634119b41c983ab52281fc0aca2">MCGS_SUCCESS</a> if successful, otherwise <a class="el" href="mcgs_8hpp.html#a212b21098b92f9d4db5bb30a9382e30d">MCGS_FAILURE</a>. </dd></dl>

</div>
</div>
<a id="ac684ffc12d9d07249de79137ebfa4ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac684ffc12d9d07249de79137ebfa4ad0">&#9670;&nbsp;</a></span>revertReorder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIndex , class TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mcgs::revertReorder </td>
          <td>(</td>
          <td class="paramtype">TValue *&#160;</td>
          <td class="paramname"><em>pRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>rowCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcgs_1_1Partition.html">Partition</a>&lt; TIndex &gt; *&#160;</td>
          <td class="paramname"><em>pPartition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore the original order of a <a class="el" href="namespacemcgs.html#a17236ad40bf333770b858d20b1e860fb">reordered</a> vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIndex</td><td>Integer type of the partition (<code>int</code>, <code>long</code>, <code>unsigned</code> or <code>unsigned long</code>). </td></tr>
    <tr><td class="paramname">TValue</td><td>Number type of stored entries in the vector (for now, only <code>double</code> is supported).</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pRHS</td><td>Dense vector to be reordered. </td></tr>
    <tr><td class="paramname">rowCount</td><td>Size of the dense vector (should be equal to the number of columns in the associated matrix). </td></tr>
    <tr><td class="paramname">pPartition</td><td>Pointer to the original <a class="el" href="classmcgs_1_1Partition.html">Partition</a> the vector was reordered by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="mcgs_8hpp.html#a46be1634119b41c983ab52281fc0aca2">MCGS_SUCCESS</a> if successful, otherwise <a class="el" href="mcgs_8hpp.html#a212b21098b92f9d4db5bb30a9382e30d">MCGS_FAILURE</a>. </dd></dl>

</div>
</div>
<a id="ae4022f391e69fa07ab52486195906764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4022f391e69fa07ab52486195906764">&#9670;&nbsp;</a></span>solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIndex , class TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mcgs::solve </td>
          <td>(</td>
          <td class="paramtype">TValue *&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmcgs_1_1CSRAdaptor.html">CSRAdaptor</a>&lt; TIndex, TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>rMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TValue *&#160;</td>
          <td class="paramname"><em>pRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmcgs_1_1Partition.html">Partition</a>&lt; TIndex &gt; *&#160;</td>
          <td class="paramname"><em>pPartition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmcgs_1_1SolveSettings.html">SolveSettings</a>&lt; TIndex, TValue &gt;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform Gauss-Seidel relaxation on a reordered system in parallel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIndex</td><td>Integer type of stored indices (<code>int</code>, <code>long</code>, <code>unsigned</code> or <code>unsigned long</code>). </td></tr>
    <tr><td class="paramname">TValue</td><td>Number type of stored entries (for now, only <code>double</code> is supported).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Algorithm</dt><dd>Given the linear system \( a_{ij} x_j^0 = b_i \) and the decomposition of \(a_{ij}\) into the sum of a strictly lower triangular matrix \(l_{ij}\), a diagonal matrix \(d_{ij}\) and strictly upper triangular matrix \(u_{ij}\) ( \( a_{ij} = l_{ij} + d_{ij} + u_{ij} \)), this function computes <p class="formulaDsp">
\[ x_j^{k+1} = (1 - \omega)x_j^k + \frac{\omega}{a_{jj}} (b_j - \sum_{i&lt;j}{a_{ji} x_i^{k+1}} - \sum_{i&lt;j}{a_{ji} x_i^k}) \]
</p>
 where \(\omega\) is a user-selected relaxation parameter.</dd></dl>
<dl class="section user"><dt>Prerequisites</dt><dd>The input system must be reordered with respect to a coloring of the system matrix' graph. This ensures that the algorithm doesn't run into race conditions and performs Gauss-Seidel iterations instead of some aliased product.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>Solution array \(x_j\). Size must be at least equal to the number of <a class="el" href="structmcgs_1_1CSRAdaptor.html#ae3747b5a9e79c0537a4b3da9469b9949">columns</a> in <code>rMatrix</code>. </td></tr>
    <tr><td class="paramname">rMatrix</td><td>Left hand side square matrix in compressed sparse row format \(a_{ij}\). </td></tr>
    <tr><td class="paramname">pRHS</td><td>Right hand side vector \(b_i\). Size must be at least equal to the number of <a class="el" href="structmcgs_1_1CSRAdaptor.html#ae2dd01c5485f57bacc1328afa1b9d5c6">rows</a> in <code>rMatrix</code>. </td></tr>
    <tr><td class="paramname">pPartition</td><td>Contiguous partition of the input matrix. </td></tr>
    <tr><td class="paramname">settings</td><td><a class="el" href="structmcgs_1_1SolveSettings.html">algorithmic parameters and other settings</a> to apply during relaxation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="mcgs_8hpp.html#a46be1634119b41c983ab52281fc0aca2">MCGS_SUCCESS</a> if successful, otherwise <a class="el" href="mcgs_8hpp.html#a212b21098b92f9d4db5bb30a9382e30d">MCGS_FAILURE</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemcgs.html#a87a15788e753a30cc3f8f621ba2a48fb" title="Perform Gauss-Seidel relaxation in serial.">solve(TValue*,const CSRAdaptor&amp;,const TValue*,const SolveSettings)</a> </dd>
<dd>
<a class="el" href="namespacemcgs.html#ad660f970843b8c8edea18c6e9291f6e5" title="Compute an approximate coloring of a graph.">color</a> </dd>
<dd>
<a class="el" href="namespacemcgs.html#a17236ad40bf333770b858d20b1e860fb" title="Reorder rows and columns of a CSR matrix as well as a matching dense vector, with respect to a colori...">reorder</a> </dd></dl>

</div>
</div>
<a id="a87a15788e753a30cc3f8f621ba2a48fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a15788e753a30cc3f8f621ba2a48fb">&#9670;&nbsp;</a></span>solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TIndex , class TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">mcgs::solve </td>
          <td>(</td>
          <td class="paramtype">TValue *&#160;</td>
          <td class="paramname"><em>pSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmcgs_1_1CSRAdaptor.html">CSRAdaptor</a>&lt; TIndex, TValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>rMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TValue *&#160;</td>
          <td class="paramname"><em>pRHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmcgs_1_1SolveSettings.html">SolveSettings</a>&lt; TIndex, TValue &gt;&#160;</td>
          <td class="paramname"><em>settings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform Gauss-Seidel relaxation in serial. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIndex</td><td>Integer type of stored indices (<code>int</code>, <code>long</code>, <code>unsigned</code> or <code>unsigned long</code>). </td></tr>
    <tr><td class="paramname">TValue</td><td>Number type of stored entries (for now, only <code>double</code> is supported).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Algorithm</dt><dd>Given the linear system \( a_{ij} x_j^0 = b_i \) and the decomposition of \(a_{ij}\) into the sum of a strictly lower triangular matrix \(l_{ij}\), a diagonal matrix \(d_{ij}\) and strictly upper triangular matrix \(u_{ij}\) ( \( a_{ij} = l_{ij} + d_{ij} + u_{ij} \)), this function computes <p class="formulaDsp">
\[ x_j^{k+1} = (1 - \omega)x_j^k + \frac{\omega}{a_{jj}} (b_j - \sum_{i&lt;j}{a_{ji} x_i^{k+1}} - \sum_{i&gt;j}{a_{ji} x_i^k}) \]
</p>
 where \(\omega\) is a user-selected relaxation parameter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSolution</td><td>Solution array \(x_j\). Size must be at least equal to the number of <a class="el" href="structmcgs_1_1CSRAdaptor.html#ae3747b5a9e79c0537a4b3da9469b9949">columns</a> in <code>rMatrix</code>. </td></tr>
    <tr><td class="paramname">rMatrix</td><td>Left hand side square matrix in compressed sparse row format \(a_{ij}\). </td></tr>
    <tr><td class="paramname">pRHS</td><td>Right hand side vector \(b_i\). Size must be at least equal to the number of <a class="el" href="structmcgs_1_1CSRAdaptor.html#ae2dd01c5485f57bacc1328afa1b9d5c6">rows</a> in <code>rMatrix</code>. </td></tr>
    <tr><td class="paramname">settings</td><td><a class="el" href="structmcgs_1_1SolveSettings.html">algorithmic parameters and other settings</a> to apply during relaxation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="mcgs_8hpp.html#a46be1634119b41c983ab52281fc0aca2">MCGS_SUCCESS</a> if successful, otherwise <a class="el" href="mcgs_8hpp.html#a212b21098b92f9d4db5bb30a9382e30d">MCGS_FAILURE</a>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacemcgs.html#ae4022f391e69fa07ab52486195906764" title="Perform Gauss-Seidel relaxation on a reordered system in parallel.">solve(TValue*,const CSRAdaptor&amp;,const TValue*,const Partition*,const SolveSettings)</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemcgs.html">mcgs</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
